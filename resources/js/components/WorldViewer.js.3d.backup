import * as THREE from 'three';

export class WorldViewer {
    constructor(containerId, options = {}) {
        this.containerId = containerId;
        this.container = document.getElementById(containerId);

        if (!this.container) {
            console.error(`Container with id "${containerId}" not found`);
            return;
        }

        // Options
        this.options = {
            chunkSize: options.chunkSize ?? 20,
            enableBuilding: options.enableBuilding ?? false,
            showMiniMap: options.showMiniMap ?? true,
            viewMode: options.viewMode ?? 'isometric', // 'isometric' or 'topdown'
            tileWidth: 32,
            tileHeight: 16,
            ...options
        };

        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.structures = new Map(); // Map of structure id -> mesh
        this.currentChunk = { x: -10, y: -10 };
        this.animationId = null;
        this.isLoading = true;
        this.selectedStructure = null;

        // Camera controls
        this.isDragging = false;
        this.previousMousePosition = { x: 0, y: 0 };
        this.cameraPosition = { x: 0, y: 0 };

        // Build mode
        this.buildPanel = null;
        this.positionMarkers = new Map();
        this.highlightedPosition = null;

        this.init();
    }

    async init() {
        try {
            this.showLoading();

            // Setup Three.js scene
            this.setupScene();
            this.setupCamera();
            this.setupRenderer();
            this.setupLights();

            // Load initial map chunk
            await this.loadChunk(this.currentChunk.x, this.currentChunk.y);

            // Setup controls
            this.setupControls();

            // Initialize build panel if building is enabled
            if (this.options.enableBuilding) {
                console.log('Building is enabled, initializing build panel...');
                const buildPanelElement = document.getElementById('build-panel');
                if (!buildPanelElement) {
                    console.warn('Build panel element not found in DOM. Make sure you are logged in and the @auth directive is rendering the panel.');
                } else {
                    this.buildPanel = new BuildPanel(this, this.container);
                    await this.buildPanel.init();
                }
            } else {
                console.log('Building is disabled (user not authenticated)');
            }

            // Start animation
            this.animate();

            // Handle resize
            window.addEventListener('resize', () => this.onResize());

            this.hideLoading();
        } catch (error) {
            console.error('World viewer initialization error:', error);
            this.showError('Failed to initialize world viewer');
        }
    }

    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a1a2e); // Dark blue background

        // Add grid helper
        const gridSize = 100;
        const gridHelper = new THREE.GridHelper(gridSize, gridSize, 0x404040, 0x202020);
        gridHelper.rotation.x = Math.PI / 2;
        this.scene.add(gridHelper);
    }

    setupCamera() {
        // Orthographic camera for isometric view
        const aspect = this.container.clientWidth / this.container.clientHeight;
        const frustumSize = 50;

        this.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );

        // Isometric angle
        this.camera.position.set(30, 30, 30);
        this.camera.lookAt(0, 0, 0);
    }

    setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
            powerPreference: 'high-performance'
        });

        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Add renderer to container
        const canvasWrapper = document.createElement('div');
        canvasWrapper.className = 'world-canvas-wrapper';
        canvasWrapper.appendChild(this.renderer.domElement);
        this.container.appendChild(canvasWrapper);
    }

    setupLights() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        // Main directional light
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
        mainLight.position.set(10, 20, 10);
        this.scene.add(mainLight);

        // Fill light
        const fillLight = new THREE.DirectionalLight(0x8888ff, 0.2);
        fillLight.position.set(-10, 5, -10);
        this.scene.add(fillLight);
    }

    async loadChunk(chunkX, chunkY) {
        try {
            const response = await fetch(
                `/api/v1/world/map?chunk_x=${chunkX}&chunk_y=${chunkY}&size=${this.options.chunkSize}`
            );

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();

            if (result.success) {
                this.renderStructures(result.data.structures);
                this.renderZones(result.data.zones);
            }
        } catch (error) {
            console.error('Error loading chunk:', error);
        }
    }

    renderStructures(structures) {
        // Clear existing structures
        this.structures.forEach((mesh) => {
            this.scene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
        });
        this.structures.clear();

        // Render new structures
        structures.forEach((structure) => {
            const mesh = this.createStructureMesh(structure);
            this.scene.add(mesh);
            this.structures.set(structure.id, mesh);
        });
    }

    createStructureMesh(structure) {
        const isoPos = this.gridToIso(structure.x, structure.y);

        // Create structure based on type and level
        const height = 0.5 + (structure.level * 0.3);
        const width = 0.8;
        const depth = 0.8;

        const geometry = new THREE.BoxGeometry(width, height, depth);

        // Color based on structure type
        const color = new THREE.Color(structure.color);

        // Apply decay state opacity
        const opacity = structure.decay_state === 'active' ? 1.0 :
                       structure.decay_state === 'fading' ? 0.7 : 0.4;

        const material = new THREE.MeshPhongMaterial({
            color: color,
            transparent: opacity < 1.0,
            opacity: opacity,
            emissive: color,
            emissiveIntensity: 0.2,
            shininess: 60,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(isoPos.x, height / 2, isoPos.y);

        // Store structure data
        mesh.userData = {
            structureId: structure.id,
            structureData: structure,
        };

        // Add wireframe for detail
        const wireframeGeo = new THREE.EdgesGeometry(geometry);
        const wireframeMat = new THREE.LineBasicMaterial({
            color: 0xffffff,
            opacity: 0.3,
            transparent: true
        });
        const wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);
        mesh.add(wireframe);

        return mesh;
    }

    renderZones(zones) {
        // Render zone boundaries (optional visual)
        zones.forEach((zone) => {
            if (!zone.is_unlocked) return;

            const centerX = (zone.bounds.min_x + zone.bounds.max_x) / 2;
            const centerY = (zone.bounds.min_y + zone.bounds.max_y) / 2;
            const width = zone.bounds.max_x - zone.bounds.min_x;
            const height = zone.bounds.max_y - zone.bounds.min_y;

            const isoPos = this.gridToIso(centerX, centerY);

            // Create zone plane
            const geometry = new THREE.PlaneGeometry(width * 0.8, height * 0.8);
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color(zone.color),
                transparent: true,
                opacity: 0.05,
                side: THREE.DoubleSide
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.position.set(isoPos.x, 0.01, isoPos.y);
            plane.rotation.x = -Math.PI / 2;
            this.scene.add(plane);
        });
    }

    gridToIso(gridX, gridY) {
        const isoX = (gridX - gridY) * this.options.tileWidth / 2;
        const isoY = (gridX + gridY) * this.options.tileHeight / 2;
        return { x: isoX, y: isoY };
    }

    isoToGrid(screenX, screenY) {
        const gridX = Math.round((screenX / this.options.tileWidth + screenY / this.options.tileHeight));
        const gridY = Math.round((screenY / this.options.tileHeight - screenX / this.options.tileWidth));
        return { x: gridX, y: gridY };
    }

    setupControls() {
        const canvas = this.renderer.domElement;

        // Mouse drag to pan
        canvas.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                const deltaX = e.clientX - this.previousMousePosition.x;
                const deltaY = e.clientY - this.previousMousePosition.y;

                this.camera.position.x -= deltaX * 0.05;
                this.camera.position.z -= deltaY * 0.05;

                this.previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mouseup', () => {
            this.isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            this.isDragging = false;
        });

        // Click to select structure
        canvas.addEventListener('click', (e) => {
            if (this.isDragging) return;
            this.handleClick(e);
        });

        // Zoom with mouse wheel
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? 1 : -1;

            this.camera.zoom = Math.max(0.5, Math.min(3, this.camera.zoom - delta * zoomSpeed));
            this.camera.updateProjectionMatrix();
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                this.isDragging = true;
                this.previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (this.isDragging && e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - this.previousMousePosition.x;
                const deltaY = e.touches[0].clientY - this.previousMousePosition.y;

                this.camera.position.x -= deltaX * 0.05;
                this.camera.position.z -= deltaY * 0.05;

                this.previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        });

        canvas.addEventListener('touchend', () => {
            this.isDragging = false;
        });
    }

    handleClick(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((event.clientX - rect.left) / rect.width) * 2 - 1,
            -((event.clientY - rect.top) / rect.height) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);

        const intersects = raycaster.intersectObjects(Array.from(this.structures.values()));

        if (intersects.length > 0) {
            const structure = intersects[0].object.userData.structureData;
            this.onStructureSelected(structure);
        }
    }

    onStructureSelected(structure) {
        console.log('Structure selected:', structure);

        // Dispatch custom event for structure selection
        const event = new CustomEvent('structure-selected', {
            detail: structure
        });
        this.container.dispatchEvent(event);

        // Optional: Show structure details panel
        this.showStructureDetails(structure);
    }

    showStructureDetails(structure) {
        // Create or update details panel
        let panel = document.getElementById('structure-details-panel');

        if (!panel) {
            panel = document.createElement('div');
            panel.id = 'structure-details-panel';
            panel.className = 'structure-details-panel';
            this.container.appendChild(panel);
        }

        const name = structure.name || structure.type_name;
        const description = structure.description || '';

        panel.innerHTML = `
            <div class="structure-details-header">
                <h3>${name}</h3>
                <button class="close-btn" onclick="this.parentElement.parentElement.remove()">Ã—</button>
            </div>
            <div class="structure-details-body">
                ${description ? `<p class="structure-description">${description}</p>` : ''}
                <div class="detail-row">
                    <span class="label">Owner:</span>
                    <span class="value">${structure.user_name}</span>
                </div>
                <div class="detail-row">
                    <span class="label">Type:</span>
                    <span class="value">${structure.type_name}</span>
                </div>
                <div class="detail-row">
                    <span class="label">Level:</span>
                    <span class="value">${structure.level}</span>
                </div>
                <div class="detail-row">
                    <span class="label">Position:</span>
                    <span class="value">(${structure.x}, ${structure.y})</span>
                </div>
                <div class="detail-row">
                    <span class="label">Status:</span>
                    <span class="value">${structure.decay_state}</span>
                </div>
            </div>
        `;
    }

    animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        this.renderer.render(this.scene, this.camera);
    }

    onResize() {
        if (!this.camera || !this.renderer) return;

        const aspect = this.container.clientWidth / this.container.clientHeight;
        const frustumSize = 50;

        this.camera.left = frustumSize * aspect / -2;
        this.camera.right = frustumSize * aspect / 2;
        this.camera.top = frustumSize / 2;
        this.camera.bottom = frustumSize / -2;

        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    }

    showLoading() {
        this.container.innerHTML = `
            <div class="world-loading">
                <div class="loading-spinner"></div>
                <p>Loading world...</p>
            </div>
        `;
    }

    hideLoading() {
        const loading = this.container.querySelector('.world-loading');
        if (loading) {
            loading.remove();
        }
    }

    showError(message) {
        this.container.innerHTML = `
            <div class="world-error">
                <p>${message}</p>
            </div>
        `;
    }

    highlightPosition(x, y, bonuses, color) {
        this.clearPositionHighlights();

        const marker = this.createPositionMarker(x, y, true, bonuses, color);
        this.positionMarkers.set(`${x},${y}`, marker);
        this.scene.add(marker);
        this.highlightedPosition = { x, y };
    }

    clearPositionHighlights() {
        if (!this.positionMarkers) return;

        this.positionMarkers.forEach((marker) => {
            this.scene.remove(marker);
            if (marker.geometry) marker.geometry.dispose();
            if (marker.material) marker.material.dispose();
        });
        this.positionMarkers.clear();
        this.highlightedPosition = null;
    }

    createPositionMarker(x, y, isSelected, bonuses, color) {
        const isoPos = this.gridToIso(x, y);

        const geometry = new THREE.BoxGeometry(0.9, 0.1, 0.9);
        const markerColor = new THREE.Color(color || '#60a5fa');

        const material = new THREE.MeshPhongMaterial({
            color: markerColor,
            transparent: true,
            opacity: 0.6,
            emissive: markerColor,
            emissiveIntensity: 0.5,
        });

        const marker = new THREE.Mesh(geometry, material);
        marker.position.set(isoPos.x, 0.05, isoPos.y);

        marker.userData = {
            isPositionMarker: true,
            x, y,
            bonuses,
            pulseTime: 0
        };

        return marker;
    }

    updatePositionMarkerColor(x, y, color) {
        if (!this.positionMarkers) return;

        const key = `${x},${y}`;
        const marker = this.positionMarkers.get(key);
        if (marker && marker.material) {
            const newColor = new THREE.Color(color);
            marker.material.color = newColor;
            marker.material.emissive = newColor;
        }
    }

    async refreshMap() {
        await this.loadChunk(this.currentChunk.x, this.currentChunk.y);
    }

    updateResourceBar(resources) {
        const updates = {
            'resource-stone': resources.stone,
            'resource-wood': resources.wood,
            'resource-crystal': resources.crystal_shards,
            'resource-magic': resources.magic_essence,
        };

        Object.entries(updates).forEach(([id, value]) => {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value ?? 0;
                el.classList.add('resource-updated');
                setTimeout(() => el.classList.remove('resource-updated'), 500);
            }
        });
    }

    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        if (this.renderer) {
            this.renderer.dispose();
        }

        if (this.scene) {
            this.scene.traverse((object) => {
                if (object.geometry) {
                    object.geometry.dispose();
                }
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }

        window.removeEventListener('resize', () => this.onResize());
    }
}

// BuildPanel class
class BuildPanel {
    constructor(worldViewer, container) {
        this.worldViewer = worldViewer;
        this.container = container;
        this.panelElement = null;

        this.resources = null;
        this.structureTypes = null;
        this.selectedType = null;
        this.positions = [];
        this.selectedPosition = null;
        this.customization = {
            name: '',
            colors: { primary: '' }
        };
        this.isLoading = false;

        this.apiBase = container.dataset.apiBase || '/api/v1/world';
        this.csrfToken = container.dataset.csrfToken ||
                         document.querySelector('meta[name="csrf-token"]')?.content;
    }

    async init() {
        console.log('BuildPanel init started');
        this.panelElement = document.getElementById('build-panel');
        if (!this.panelElement) {
            console.error('Build panel element not found');
            return;
        }
        console.log('Build panel element found');

        await this.loadResources();
        console.log('Resources loaded:', this.resources);
        await this.loadStructureTypes();
        console.log('Structure types loaded');
        this.render();
        console.log('Panel rendered');
        this.show();
        console.log('Panel shown');
    }

    async loadResources() {
        try {
            const response = await axios.get(`${this.apiBase}/my-resources`);
            if (response.data.success) {
                this.resources = response.data.data;
            }
        } catch (error) {
            console.error('Failed to load resources:', error);
            this.showMessage('Failed to load resources', 'error');
        }
    }

    async loadStructureTypes() {
        this.structureTypes = [
            { type: 'cottage', name: 'Cottage', costs: { stone: 5, wood: 3 }, icon: 'ðŸ ' },
            { type: 'workshop', name: 'Workshop', costs: { stone: 10, crystal_shards: 5 }, icon: 'ðŸ”§' },
            { type: 'gallery', name: 'Gallery', costs: { wood: 8, crystal_shards: 8 }, icon: 'ðŸŽ¨' },
            { type: 'library', name: 'Library', costs: { wood: 15, stone: 5 }, icon: 'ðŸ“š' },
            { type: 'academy', name: 'Academy', costs: { stone: 20, wood: 10 }, icon: 'ðŸ›ï¸' },
            { type: 'tower', name: 'Tower', costs: { crystal_shards: 15, magic_essence: 10 }, icon: 'ðŸ—¼' },
            { type: 'monument', name: 'Monument', costs: { stone: 30, wood: 30, crystal_shards: 30, magic_essence: 30 }, icon: 'ðŸ†' },
            { type: 'garden', name: 'Garden', costs: { wood: 5, magic_essence: 5 }, icon: 'ðŸŒ³' },
        ];
    }

    canAfford(costs) {
        if (!this.resources?.resources) return false;
        const res = this.resources.resources;
        return Object.entries(costs).every(([resource, amount]) =>
            (res[resource] || 0) >= amount
        );
    }

    render() {
        this.panelElement.innerHTML = `
            <div class="build-panel-header">
                <h3>Build Structure</h3>
            </div>

            <div class="build-panel-section">
                <div class="build-panel-section-title">Select Structure Type</div>
                <div class="structure-type-grid">
                    ${this.renderStructureTypes()}
                </div>
            </div>

            <div class="build-panel-section position-section" style="display: none;">
                <div class="build-panel-section-title">Select Position</div>
                <div class="position-list"></div>
            </div>

            <div class="build-panel-section customization-section" style="display: none;">
                <div class="build-panel-section-title">Customize</div>
                <div class="customization-field">
                    <label class="customization-label">Name (max 30 chars)</label>
                    <input type="text"
                           class="customization-input"
                           id="structure-name"
                           maxlength="30"
                           placeholder="Enter structure name">
                </div>
                <div class="customization-field">
                    <label class="customization-label">Primary Color</label>
                    <div class="color-picker-wrapper">
                        <div class="color-preview" id="color-preview"></div>
                        <input type="color"
                               class="color-input"
                               id="structure-color"
                               value="#8B4513">
                    </div>
                </div>
            </div>

            <div class="build-panel-actions">
                <button class="build-button" id="build-button" disabled>
                    <span class="build-button-text">Select type and position</span>
                </button>
            </div>

            <div class="build-message" id="build-message" style="display: none;"></div>
        `;

        this.attachEventListeners();
    }

    renderStructureTypes() {
        return this.structureTypes.map(st => {
            const affordable = this.canAfford(st.costs);
            return `
                <div class="structure-type-card ${affordable ? '' : 'disabled'}"
                     data-type="${st.type}"
                     ${affordable ? '' : 'title="Insufficient resources"'}>
                    <div class="structure-icon">${st.icon}</div>
                    <div class="structure-info">
                        <div class="structure-name">${st.name}</div>
                        <div class="structure-costs">
                            ${this.renderCosts(st.costs)}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }

    renderCosts(costs) {
        const resourceIcons = {
            stone: 'ðŸª¨',
            wood: 'ðŸªµ',
            crystal_shards: 'ðŸ’Ž',
            magic_essence: 'âœ¨'
        };
        const userRes = this.resources?.resources || {};

        return Object.entries(costs).map(([resource, amount]) => {
            const has = userRes[resource] || 0;
            const insufficient = has < amount;
            return `
                <span class="structure-cost-badge ${insufficient ? 'insufficient' : ''}">
                    ${resourceIcons[resource] || ''} ${amount}
                </span>
            `;
        }).join('');
    }

    attachEventListeners() {
        this.panelElement.querySelectorAll('.structure-type-card:not(.disabled)')
            .forEach(card => {
                card.addEventListener('click', () => this.selectType(card.dataset.type));
            });

        const nameInput = this.panelElement.querySelector('#structure-name');
        nameInput?.addEventListener('input', (e) => {
            this.customization.name = e.target.value.substring(0, 30);
        });

        const colorInput = this.panelElement.querySelector('#structure-color');
        const colorPreview = this.panelElement.querySelector('#color-preview');
        colorInput?.addEventListener('input', (e) => {
            this.customization.colors.primary = e.target.value;
            if (colorPreview) {
                colorPreview.style.backgroundColor = e.target.value;
            }
            if (this.selectedPosition) {
                this.worldViewer.updatePositionMarkerColor(
                    this.selectedPosition.x,
                    this.selectedPosition.y,
                    e.target.value
                );
            }
        });

        const buildButton = this.panelElement.querySelector('#build-button');
        buildButton?.addEventListener('click', () => this.submitBuild());
    }

    async selectType(type) {
        this.panelElement.querySelectorAll('.structure-type-card').forEach(card => {
            card.classList.toggle('selected', card.dataset.type === type);
        });

        this.selectedType = type;
        this.selectedPosition = null;

        this.worldViewer.clearPositionHighlights();

        await this.loadPositions(type);
        await this.loadCustomizationDefaults(type);

        this.panelElement.querySelector('.position-section').style.display = 'block';
        this.updateBuildButtonState();
    }

    async loadPositions(type) {
        const positionList = this.panelElement.querySelector('.position-list');
        positionList.innerHTML = '<div class="loading-spinner"></div>';

        try {
            const response = await axios.get(
                `${this.apiBase}/suggest-positions?type=${type}&limit=5`
            );

            if (response.data.success) {
                this.positions = response.data.data;
                this.renderPositions();
            }
        } catch (error) {
            console.error('Failed to load positions:', error);
            positionList.innerHTML = '<div class="error">Failed to load positions</div>';
        }
    }

    renderPositions() {
        const positionList = this.panelElement.querySelector('.position-list');

        if (this.positions.length === 0) {
            positionList.innerHTML = '<div class="no-positions">No positions available</div>';
            return;
        }

        positionList.innerHTML = this.positions.map((pos, index) => `
            <div class="position-item" data-index="${index}" data-x="${pos.x}" data-y="${pos.y}">
                <div class="position-coords">(${pos.x}, ${pos.y})</div>
                <div class="position-bonuses">
                    ${Object.values(pos.bonuses || {}).map(bonus =>
                        `<span class="position-bonus-tag">${bonus}</span>`
                    ).join('')}
                </div>
                ${pos.score ? `<div class="position-score">Score: ${pos.score.toFixed(1)}</div>` : ''}
            </div>
        `).join('');

        positionList.querySelectorAll('.position-item').forEach(item => {
            item.addEventListener('click', () => {
                const x = parseInt(item.dataset.x);
                const y = parseInt(item.dataset.y);
                const index = parseInt(item.dataset.index);
                this.selectPosition(x, y, this.positions[index]);
            });
        });
    }

    selectPosition(x, y, positionData) {
        this.panelElement.querySelectorAll('.position-item').forEach(item => {
            const itemX = parseInt(item.dataset.x);
            const itemY = parseInt(item.dataset.y);
            item.classList.toggle('selected', itemX === x && itemY === y);
        });

        this.selectedPosition = { x, y, ...positionData };

        this.worldViewer.clearPositionHighlights();
        this.worldViewer.highlightPosition(x, y, positionData.bonuses, this.customization.colors.primary);

        this.panelElement.querySelector('.customization-section').style.display = 'block';
        this.updateBuildButtonState();
    }

    async loadCustomizationDefaults(type) {
        try {
            const response = await axios.get(`${this.apiBase}/customization/${type}`);

            if (response.data.success) {
                const defaults = response.data.data.defaults;

                const nameInput = this.panelElement.querySelector('#structure-name');
                const colorInput = this.panelElement.querySelector('#structure-color');
                const colorPreview = this.panelElement.querySelector('#color-preview');

                if (nameInput && defaults.name) {
                    nameInput.value = defaults.name;
                    nameInput.placeholder = defaults.name;
                    this.customization.name = defaults.name;
                }

                if (colorInput && defaults.colors?.primary) {
                    colorInput.value = defaults.colors.primary;
                    this.customization.colors.primary = defaults.colors.primary;
                    if (colorPreview) {
                        colorPreview.style.backgroundColor = defaults.colors.primary;
                    }
                }
            }
        } catch (error) {
            console.error('Failed to load customization defaults:', error);
        }
    }

    updateBuildButtonState() {
        const button = this.panelElement.querySelector('#build-button');
        const buttonText = button.querySelector('.build-button-text');

        if (!this.selectedType) {
            button.disabled = true;
            buttonText.textContent = 'Select a structure type';
        } else if (!this.selectedPosition) {
            button.disabled = true;
            buttonText.textContent = 'Select a position';
        } else {
            button.disabled = false;
            const typeName = this.structureTypes.find(t => t.type === this.selectedType)?.name;
            buttonText.textContent = `Build ${typeName}`;
        }
    }

    async submitBuild() {
        if (!this.selectedType || !this.selectedPosition) return;

        const button = this.panelElement.querySelector('#build-button');
        const buttonText = button.querySelector('.build-button-text');

        button.disabled = true;
        button.classList.add('loading');
        buttonText.textContent = 'Building...';

        try {
            const response = await axios.post(`${this.apiBase}/build`, {
                type: this.selectedType,
                x: this.selectedPosition.x,
                y: this.selectedPosition.y,
                customization: {
                    name: this.customization.name || undefined,
                    colors: {
                        primary: this.customization.colors.primary || undefined
                    }
                }
            }, {
                headers: {
                    'X-CSRF-TOKEN': this.csrfToken
                }
            });

            if (response.data.success) {
                this.showMessage('Structure built successfully!', 'success');

                if (response.data.data.resources) {
                    this.resources = response.data.data.resources;
                    this.worldViewer.updateResourceBar(response.data.data.resources.resources);
                }

                await this.worldViewer.refreshMap();
                this.reset();
            } else {
                this.showMessage(response.data.message || 'Failed to build structure', 'error');
            }
        } catch (error) {
            console.error('Build error:', error);
            const message = error.response?.data?.message || 'Failed to build structure';
            this.showMessage(message, 'error');
        } finally {
            button.classList.remove('loading');
            this.updateBuildButtonState();
        }
    }

    reset() {
        this.selectedType = null;
        this.selectedPosition = null;
        this.positions = [];
        this.customization = { name: '', colors: { primary: '' } };

        this.worldViewer.clearPositionHighlights();
        this.render();
    }

    showMessage(message, type = 'info') {
        const messageEl = this.panelElement.querySelector('#build-message');
        messageEl.textContent = message;
        messageEl.className = `build-message ${type}`;
        messageEl.style.display = 'block';

        setTimeout(() => {
            messageEl.style.display = 'none';
        }, 5000);
    }

    show() {
        this.panelElement.style.display = 'block';
    }

    hide() {
        this.panelElement.style.display = 'none';
    }
}

// Auto-initialize world viewers
document.addEventListener('DOMContentLoaded', () => {
    const worldElements = document.querySelectorAll('[data-world-viewer]');

    worldElements.forEach(element => {
        const options = {
            chunkSize: parseInt(element.dataset.chunkSize) || 20,
            enableBuilding: element.dataset.enableBuilding === 'true',
            showMiniMap: element.dataset.showMiniMap !== 'false',
        };

        new WorldViewer(element.id, options);
    });
});
